# 作用域

从test_scope.py中看到，有两种作用域。
* 模块全局作用域
  *  由在类或函数块之外被分配给值的名称
*  函数局部作用域
   *  通过参数或在函数主体中直接分配值的名称


# 闭包

见average.py，闭包也是一个函数，它保留了定义函数时存在的自由变量的绑定。这样，调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

# nonlocal

见broken_impl.py，nonlocal可以声明一个变量为自由变量，哪怕在函数内进行赋值操作。
一个新值被赋给一个nonlocal变量，闭包中绑定的值也会改变。
正确的实现见nonlocal_example.py

## 变量查找逻辑

Python字节码编译器根据以下规则后去函数主体中出现的变量x。
* 如果是global x声明，则x来自模块全局作用域，并赋予那个作用域中x的值。
* 如果是nonlocal x声明，则x来自最近一个定义它的外层函数，并赋予那个函数中局部变量x的值。
* 如果x是参数，或在函数主体中赋了值，那么x就是局部变量。
* 如果引用了x，但是没有赋值也不是参数，则遵循以下规则。
  * 在外层函数主体的局部作用域(nonlocal作用域)内查找x。
  * 如果在外层作用域内未找到，则从模块全局作用域内读取。
  * 如果在模块全局作用域内未找到，则从`__builtins__.__dict__`中读取。

# 实现一个简单的装饰器
见clockdeco0.py和clockdeco.py

# 标准库中的装饰器


## 使用functools.cache做备忘(缓存)
functools.cache装饰器实现了备忘，能把耗时的函数得到的结果保存起来，避免传入相同的参数时重复计算。见fibo_demo.py。

但这个functools.cache是没有限制的，可能会耗尽所有内存。@cache更适合短期运行的命令行脚本使用。如果是长期运行的进程，则推荐使用functools.lru_cache，并设置maxsize参数。

## 使用lru_cache

它的优势是可以通过maxsize参数限制内存使用量上限，默认是128条缓存。LRU是Least Recently Used的缩写，即最近最少使用的缓存可能会被丢弃。t
它有两个参数，一个是maxsize，另一个是typed，控制是否把不同参数类型得到的结果分开保存，默认为False,即相等的浮点数参数和整数参数只存储一次。即f(1)和f(1.0)对应一个缓存记录。


## 单分派泛化函数

functools.singledispatch装饰器可以把整体方法拆分成多个模块，它装饰的普通函数变成了泛化函数(指根据第一个参数的类型，以不同方式执行相同操作的一组函数)的入口。
这就是单分派，如果根据多个参数选择专门的函数，就是多分派。
见singledispatch_demo.py

# 参数化装饰器

Python会把被装饰的函数作为第一个参数传给装饰器函数，如果想让装饰器接受其他参数，需要创建一个装饰器工厂函数。见registration_param.py

参数化装饰器通常会把被装饰的函数替换掉，而且结构上需要多一层嵌套。

